#!/usr/bin/env python3
"""
StoryHero.gg Clone - All-in-One MVP
Run: python storyhero_one_file.py
Then open: http://localhost:8000
"""

import os
import re
import random
import string
import yt_dlp
from faster_whisper import WhisperModel
from moviepy.editor import VideoFileClip
import ffmpeg
from fastapi import FastAPI, Form, Request
from fastapi.responses import HTMLResponse, FileResponse, JSONResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
import uvicorn

# ----------------------------
# Setup
# ----------------------------
app = FastAPI()
OUTPUT_DIR = "clips"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Create templates directory
TEMPLATES_DIR = "templates"
os.makedirs(TEMPLATES_DIR, exist_ok=True)

# ----------------------------
# AI & Video Logic
# ----------------------------
_model = None

def get_whisper_model():
    global _model
    if _model is None:
        print("Loading Whisper model (first run may take 2-5 mins)...")
        _model = WhisperModel("small", device="cpu", compute_type="int8")
    return _model

def download_youtube_video(url, output_path="temp_video.mp4"):
    ydl_opts = {
        'format': 'bestvideo[height<=720]+bestaudio/best[height<=720]',
        'outtmpl': output_path,
        'noplaylist': True,
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([url])
    return output_path

def transcribe_with_timestamps(video_path):
    model = get_whisper_model()
    segments, _ = model.transcribe(video_path, word_timestamps=True)
    words = []
    for segment in segments:
        for word in segment.words:
            words.append({
                "word": word.word,
                "start": word.start,
                "end": word.end
            })
    return words

def detect_highlights(words, video_duration):
    highlights = []
    trigger_phrases = ["wait", "omg", "no way", "you won't believe", "holy", "wow", "seriously", "look", "listen"]
    i = 0
    while i < len(words):
        word = words[i]
        w_lower = word["word"].lower().strip(".,!?")

        # Start new phrase
        current_start = word["start"]
        current_phrase = [word]
        j = i + 1
        while j < len(words):
            next_word = words[j]
            gap = next_word["start"] - words[j-1]["end"]
            if gap > 1.0 or j - i >= 20:  # Max 20 words
                break
            current_phrase.append(next_word)
            j += 1

        phrase_text = " ".join(w["word"] for w in current_phrase).lower()
        phrase_end = current_phrase[-1]["end"]

        # Check for trigger or pause
        has_trigger = any(t in phrase_text for t in trigger_phrases)
        next_start = words[j]["start"] if j < len(words) else video_duration
        gap_after = next_start - phrase_end
        has_pause = gap_after > 1.2 and len(current_phrase) >= 3

        if has_trigger or has_pause:
            clip_start = max(0, current_start - 1.0)
            clip_end = min(video_duration, phrase_end + 2.0)
            if clip_end - clip_start >= 5:
                highlights.append({
                    "start": clip_start,
                    "end": clip_end,
                    "text": phrase_text.strip(),
                    "reason": "Keyword" if has_trigger else "Pause"
                })

        i = j

    # Sort by score
    highlights.sort(key=lambda x: (x["end"] - x["start"]) + (10 if x["reason"] == "Keyword" else 0), reverse=True)
    return highlights[:3]

def generate_final_clip(input_video, start, end, text, output_dir):
    temp_clip = os.path.join(output_dir, f"temp_{random_string(6)}.mp4")
    final_clip = os.path.join(output_dir, f"clip_{random_string(8)}.mp4")

    # Cut clip
    (
        ffmpeg
        .input(input_video, ss=start, to=end)
        .output(temp_clip, vcodec='libx264', acodec='aac', preset='fast')
        .overwrite_output()
        .run(quiet=True)
    )

    # Add caption
    safe_text = text.replace("'", "\\'").replace(":", "\\:")
    (
        ffmpeg
        .input(temp_clip)
        .drawtext(
            text=safe_text,
            x="(w-text_w)/2",
            y="h-th-50",
            fontsize=48,
            fontcolor="white",
            box=1,
            boxcolor="black@0.5",
            boxborderw=10
        )
        .output(final_clip, vcodec='libx264', acodec='aac', preset='fast')
        .overwrite_output()
        .run(quiet=True)
    )

    os.remove(temp_clip)
    return os.path.basename(final_clip)

def random_string(n):
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=n))

# ----------------------------
# Web UI (Embedded HTML)
# ----------------------------
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StoryHero Clone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes bounceDelay {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        .animate-bounce-delay { animation: bounceDelay 1.5s infinite; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div class="container mx-auto px-4 py-16">
        <h1 class="text-4xl md:text-6xl font-bold text-center bg-gradient-to-r from-purple-400 via-pink-500 to-red-500 bg-clip-text text-transparent mb-6">
            StoryHero Clone
        </h1>
        <p class="text-xl text-gray-300 text-center max-w-2xl mx-auto mb-10">
            Paste a YouTube URL to auto-generate viral Shorts with AI.
        </p>

        <form id="processForm" class="max-w-2xl mx-auto mb-16">
            <div class="flex flex-col sm:flex-row gap-3">
                <input
                    type="url"
                    name="url"
                    placeholder="https://youtube.com/watch?v=..."
                    class="flex-grow px-5 py-3 rounded-lg bg-gray-800 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-pink-500"
                    required
                />
                <button
                    type="submit"
                    class="px-6 py-3 bg-gradient-to-r from-pink-500 to-red-500 hover:from-pink-600 hover:to-red-600 rounded-lg font-semibold transition-all duration-300 transform hover:scale-105"
                >
                    Generate Clips
                </button>
            </div>
        </form>

        <div id="loading" class="hidden text-center text-pink-400 mb-8">Processing... This may take 1-3 minutes.</div>
        <div id="error" class="text-center text-red-400 mb-8 hidden"></div>

        <div id="results" class="hidden">
            <h2 class="text-3xl font-bold text-center mb-8">Your AI Clips</h2>
            <div id="clipsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"></div>
        </div>
    </div>

    <script>
        document.getElementById('processForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const url = e.target.url.value;
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('error').classList.add('hidden');
            document.getElementById('results').classList.add('hidden');

            try {
                const formData = new FormData();
                formData.append('url', url);
                const res = await fetch('/process', { method: 'POST', body: formData });
                const data = await res.json();

                if (data.clips && data.clips.length > 0) {
                    const container = document.getElementById('clipsContainer');
                    container.innerHTML = '';
                    data.clips.forEach(clip => {
                        const div = document.createElement('div');
                        div.className = 'bg-gray-800 rounded-xl overflow-hidden';
                        div.innerHTML = `
                            <video src="/clip/${clip}" controls class="w-full h-64 object-cover"></video>
                            <div class="p-4 text-center">
                                <a href="/clip/${clip}" download class="inline-block bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg px-4 py-2 font-medium hover:opacity-90">Download</a>
                            </div>
                        `;
                        container.appendChild(div);
                    });
                    document.getElementById('results').classList.remove('hidden');
                } else {
                    document.getElementById('error').textContent = data.error || 'No highlights found.';
                    document.getElementById('error').classList.remove('hidden');
                }
            } catch (err) {
                document.getElementById('error').textContent = 'Failed to connect to backend.';
                document.getElementById('error').classList.remove('hidden');
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        });
    </script>
</body>
</html>
"""

@app.get("/", response_class=HTMLResponse)
async def home():
    return HTML_TEMPLATE

@app.post("/process")
async def process_video(url: str = Form(...)):
    try:
        print(f"Processing: {url}")
        video_path = download_youtube_video(url)
        words = transcribe_with_timestamps(video_path)
        clip = VideoFileClip(video_path)
        duration = clip.duration
        clip.close()
        highlights = detect_highlights(words, duration)
        clip_paths = []
        for hl in highlights:
            filename = generate_final_clip(video_path, hl["start"], hl["end"], hl["text"], OUTPUT_DIR)
            clip_paths.append(filename)
        os.remove(video_path)
        return JSONResponse({"clips": clip_paths})
    except Exception as e:
        print(f"Error: {e}")
        return JSONResponse({"error": str(e)}, status_code=500)

@app.get("/clip/{filename}")
async def get_clip(filename: str):
    path = os.path.join(OUTPUT_DIR, filename)
    if os.path.exists(path):
        return FileResponse(path)
    return {"error": "Clip not found"}

# ----------------------------
# Run
# ----------------------------
if __name__ == "__main__":
    print("üöÄ Starting StoryHero Clone...")
    print("üëâ Open http://localhost:8000 in your browser")
    print("‚ö†Ô∏è  First run will download the Whisper model (~500MB)")
    uvicorn.run(app, host="0.0.0.0", port=8000)
